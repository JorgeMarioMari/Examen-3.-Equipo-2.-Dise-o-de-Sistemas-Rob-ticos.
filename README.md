# Manual de la solución del Examen 3 #
En este manual se trabajó con un código en lenguaje Python que se utiliza para controlar un robot que se mueve hacia diferentes puntos en un mapa resolviendo un laberinto en cada uno de los movimientos que generan. Por supuesto, el mapa es un laberinto que está diseñado para que empecemos con el robot en el centro y terminemos en la esquina superior derecha. El código está diseñado para trabajar con ROS (Robot Operating System) y utiliza varias bibliotecas y módulos de ROS para lograr su objetivo. 
Para entender el código en profundidad, se pueden seguir los siguientes pasos:

1. Primero, se especifica que se está utilizando el intérprete de Python y se importan los módulos necesarios para ejecutar el código. Los módulos importados son "rospy" que se utiliza para trabajar con ROS, "Odometry" y "Point" para representar la información de la posición y la dirección del robot, "Twist" para establecer la velocidad y la dirección del movimiento del robot, "euler_from_quaternion" para convertir la información de la orientación del robot desde el formato cuaternión al formato de Euler y "math" para realizar operaciones matemáticas.

2. A continuación, se importa un archivo llamado "prueba3.py" que contiene la definición de una clase "stop" para detener el robot.

3. Asimismo, se define una clase llamada "Controller" que se encarga de controlar el movimiento del robot. La clase tiene un constructor que toma el punto objetivo hacia el que se mueve el robot. En el constructor, se inicializan las variables que se utilizan para almacenar la posición actual del robot y la dirección en la que se está moviendo. También se crean un objeto "cmd" de la clase "Twist" y se establecen los valores iniciales de la velocidad y la dirección del robot. Además, se suscriben los datos de posición del robot en la suscripción "/odom" y se publican los comandos de movimiento en la publicación "/cmd_vel".

4. A su vez, La clase "Controller" también define una función llamada "new_odom" que se ejecuta cada vez que se recibe una nueva posición del robot. En esta función, se actualizan las variables que almacenan la posición actual del robot y la dirección en la que se está moviendo.
 
5. Después, la clase "Controller" también define una función llamada "run" que se ejecuta en un bucle hasta que se detiene el robot o se alcanza el objetivo. En la función "run", se calcula la diferencia entre la posición actual del robot y el punto objetivo. A partir de esta diferencia, se calcula el ángulo que debe tener el robot para llegar al punto objetivo. Si el ángulo es mayor que 0.1, se establece la velocidad lineal del robot en cero y la velocidad angular en 0.2 para girar hacia el objetivo. Si el ángulo es menor o igual que 0.1, se establece la velocidad lineal del robot en 0.5 y la velocidad angular en cero para avanzar hacia el objetivo. Por último, se publica el comando de movimiento y se comprueba si se ha alcanzado el objetivo. Si la posición actual del robot está a menos de 0.1 de la posición objetivo, se detiene el robot.
 
6. Finalmente, en la función principal del programa, se definen varios puntos objetivo y se crea una instancia de la clase "Controller" para cada uno de ellos. Estas instancias se almacenan en una lista llamada "controllers". Se llama a la función "run" para cada uno de los controladores en la lista "controllers".

Es así como logramos obtener el código de la implementación del controlador de robot. Por otra parte, en cuanto a los módulos importados, "rospy" es la biblioteca principal de ROS para Python y se utiliza para interactuar con el entorno de ROS. "Odometry" se utiliza para representar la posición del robot y "Point" se utiliza para representar el punto objetivo hacia el que se mueve el robot. "Twist" se utiliza para establecer la velocidad y la dirección del movimiento del robot. "euler_from_quaternion" se utiliza para convertir la información de la orientación del robot desde el formato cuaternión al formato de Euler y "math" se utiliza para realizar operaciones matemáticas.

Además, se importa un archivo llamado "prueba3.py" que contiene la definición de una clase "stop" para detener el robot. Esta clase es utilizada por el controlador para detener el robot cuando se alcanza el punto objetivo o cuando ocurre un error.

El controlador del robot se define en una clase llamada "Controller". Esta clase tiene un constructor que toma el punto objetivo hacia el que se mueve el robot. En el constructor, se inicializan las variables que se utilizan para almacenar la posición actual del robot y la dirección en la que se está moviendo. También se crea un objeto "cmd" de la clase "Twist" y se establecen los valores iniciales de la velocidad y la dirección del robot. Además, se suscriben los datos de posición del robot en la suscripción "/odom" y se publican los comandos de movimiento en la publicación "/cmd_vel".

La clase "Controller" también define una función llamada "new_odom" que se ejecuta cada vez que se recibe una nueva posición del robot. En esta función, se actualizan las variables que almacenan la posición actual del robot y la dirección en la que se está moviendo.

La función "run" es la principal del controlador y se ejecuta en un bucle hasta que se detiene el robot o se alcanza el objetivo. En la función "run", se calcula la diferencia entre la posición actual del robot y el punto objetivo. A partir de esta diferencia, se calcula el ángulo que debe tener el robot para llegar al punto objetivo. Si el ángulo es mayor que 0.1, se establece la velocidad lineal del robot en cero y la velocidad angular en 0.2 para girar hacia el objetivo. Si el ángulo es menor o igual que 0.1, se establece la velocidad lineal del robot en 0.5 y la velocidad angular en cero para avanzar hacia el objetivo. Por último, se publica el comando de movimiento y se comprueba si se ha alcanzado el objetivo. Si la posición actual del robot está a menos de 0.1 de la posición objetivo, se detiene el robot.

En la función principal del programa, se definen varios puntos objetivo y se crea una instancia de la clase "Controller" para cada uno de ellos. Estas instancias se almacenan en una lista llamada "controllers". Se llama a la función "run" para cada uno de los controladores en la lista "controllers".

Por último, el enlace del video del correcto funcionamiento del sistema es el siguiente: https://www.youtube.com/watch?v=kN1l4YopLkU
